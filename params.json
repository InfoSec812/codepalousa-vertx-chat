{"name":"Vert.x Chat Workshop","tagline":"Create a reactive, clustered, event-driven chat application in JavaScript using the Vert.x toolkit","body":"# codepalousa-vertx-chat-example\r\n\r\n## Overview\r\nThis project is a presentation which was originally created for Code PaLOUsa 2015 (http://codepalousa.com) to demonstrate \r\nwriting reactive/clustered application in Vert.x using JavaScript. The content below is the speaker's notes and are \r\nupdated as errors are found or improvements are discovered.\r\n\r\n## Introductory Slides\r\n\r\nhttp://slides.com/devenphillips/codepalousa-2015-vertx/\r\n\r\n## Speaker's Notes\r\n\r\nWe will generate a new *stub* application using a [Maven](http://maven.apache.org/) archetype.\r\n\r\n    mvn archetype:generate -DarchetypeGroupId=com.zanclus.codepalousa -DarchetypeArtifactId=vertx-js-archetype\r\n\r\nAfter creating the maven project from the Archetype, we will be left with a new stub project which has a single verticle:\r\n\r\n    src/main/resources/com/codepalousa/vertx/main.js\r\n\r\nInitially, this fille will ONLY contain:\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n\r\n    // When Vert.x creates a new verticle, the \"vertx\" instance is already part of the scope, so we do not need to declare it.\r\n\r\n    console.log(\"Main verticle deployed.\");\r\n\r\nThis is a JSlint \"hint\" to let us know that whenever Vert.x loads a JavaScript file, the \"vertx\" object is already created as a global variable in our scope.\r\n\r\nHere's the JavaScript code for a simple web server which returns \"Hello Vert.x!\":\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var server = vertx.createHttpServer();\r\n    server.requestHandler(function(req) {\r\n      req.response().putHeader(\"Content-Type\", \"text/html\").end(\"<html><body><h1>Hello Vert.x!</h1></body></html>\");\r\n    });\r\n    server.listen(9080);\r\n\r\nLet's dissect this a bit to make sure that we understand what is happening.\r\n\r\n1. We create a “server” instance. Vert.x has HTTP servers as part of the base API, so we just ask for an instance.\r\n2. Next, we call *requestHandler* with an argument of a *function literal/lambda/closure*.\r\n3. The function literal will be called every time a new request comes in to the web server and it will return \"Hello Vert.x!\" in HTML.\r\n4. Finally, we tell the server to start listening for new requests on a given port (We could also specify the listening address here if we wanted).\r\n\r\nWe could shorten this up a bit if we like by using the fluent APIs of Vert.x:\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    vertx.createHttpServer().requestHandler(function(req) {\r\n        req.response().putHeader(\"Content-Type\", \"text/html\").end(\"<html><body><h1>Hello Vert.x!</h1></body></html>\");\r\n    }).listen(9080);\r\n\r\nThough this is a little less typing, it somewhat hinders readability. Since the code is already VERY concise, I will err on the side of readability throughout this workshop so that everyone can readily follow along. Almost ALL of Vert.x's APIs are fluent and can be chained together, so you are welcome to use that in your own code.\r\n\r\nNext, let's create a second verticle.. In the same folder as *main.js*, create *ping-endpoint.js*.\r\n\r\nNow, we will tell Vert.x to use the event bus to listen for messages:\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    \r\n    // Get a reference to the event bus from the global \"vertx\" instance\r\n    var eb = vertx.eventBus();\r\n    \r\n    // Register a consumer for messages addresses to \"ping-address\" on the event bus\r\n    eb.consumer(“ping-address”, function(message) {\r\n        // This is a \"function literal\"/\"lambda\"/\"closure\" where we handle the message received from the event bus\r\n        \r\n        console.log(“Recieved Message: “ + message.body);\r\n        eb.publish(“pong-address”, “pong!”);\r\n    });\r\n\r\nThis is another simple Verticle which makes use of some core functionality in Vert.x, the Event Bus. Every verticle inside of a given Vert.x instance shares access to this event bus. Moreso, when you use the clustering option, which I will demonstrate later, multiple instances of Vert.x across multiple hosts can share an event bus so that you can build distributed systems.\r\n\r\nNow, let's have our HTTP server send pings every time we make an HTTP request:\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var server = vertx.createHttpServer();\r\n    \r\n    // Here, we are deploying another verticle programmatically\r\n    vertx.deployVerticle(“com/codepalousa/vertx/ping-endpoint.js”);\r\n    \r\n    server.requestHandler(function(req) {\r\n        req.response().putHeader(\"Content-Type\", \"text/html\").end(\"<html><body><h1>Hello Vert.x</h1></body></html>\");\r\n        vertx.eventBus().publish(“ping-address”, “ping!”);\r\n    });\r\n    \r\n    // Register a consumer for messages addresses to \"pong-address\" on the event bus\r\n    vertx.eventBus().consumer(“pong-address”, function(message) {\r\n        console.log(“Reply: “+message.body());\r\n    });\r\n    server.listen(9080);\r\n\r\nWhen we run this, every time that someone makes an HTTP request, the main Verticle will publish a message to the *ping-address* on the event bus, and we will see the request and the response logged to STDOUT:\r\n\r\n    $ java -jar target/codepalousa-vertx-example-1.0-SNAPSHOT-fat.jar \r\n    Ping verticle deployed\r\n    Apr 20, 2015 10:06:46 AM io.vertx.core.Starter\r\n    INFO: Succeeded in deploying verticle\r\n    Received Ping: ping!\r\n    Received reply: pong!\r\n    Received Ping: ping!\r\n    Received reply: pong!\r\n    Received Ping: ping!\r\n    Received reply: pong!\r\n    Received Ping: ping!\r\n    Received reply: pong!\r\n\r\nThis is a perfect opportunity to show up Vert.x clustering. To set up clustering is relatively simple. By default Vert.x uses multicast DNS to to find cluster nodes on the local network. The steps to make this work are as follows:\r\n\r\n1. Copy the “default-cluster.xml” file into your project as “src/main/resources/cluster.xml”.\r\n2. Edit the “cluster.xml” file in your project and change the <interfaces> tag so that enabled=true\r\n3. Modify the interface address to match the local network.\r\n4. Modify the pom.xml to use the cluster arguments to start your verticle.\r\n\r\nNOTE!!! When you run this inside of a docker container or a VM you will have to jump through extra hoops to ensure that the interfaces/ports/etc… are all correct.\r\n\r\n\r\nNow, let's turn this into a basic static HTTP server which will return content based on the requested path/filename..\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var server = vertx.createHttpServer();\r\n    \r\n    // This is the path from which our web server will try to serve files.\r\n    var basePath = “/var/www/html”;\r\n    \r\n    server.requestHandler(function(req) {\r\n      var file = req.path();\r\n      \r\n      // If the request is for the root of the web application, return \"index.html\".\r\n      if (file===\"/\") {\r\n        file = \"/index.html\";\r\n      }\r\n      \r\n      // Use the request path appended to the basePath to locate a file and use the asynchronous \"sendFile\" method\r\n      // to return the content to the browser.\r\n      req.response().sendFile(basePath+file, function(res, error) {\r\n        if (error!=null) {\r\n          // If there is an error trying to send the requested file it is probably because the file does not exist\r\n          // So, we need to send a 404 status code.\r\n          console.log(\"File '\"+file+\"' not found.\");\r\n          req.response().setStatusCode(404).setStatusMessage(\"NOT FOUND\").end();\r\n        }\r\n      });\r\n    });\r\n    \r\n    // Tell the HTTP server to start listening on port 9080 for new requests.\r\n    server.listen(9080);\r\n\r\nThe sendFile() function runs asynchronously, so it may not complete until some time after the function call returns (usually almost instantaneous).\r\n\r\nOK, serving static content is pretty simple. Let's move more into the “web application” realm. This requires the use of the [Vert.x Apex extension](http://vert-x3.github.io/docs/vertx-apex/js/). Apex provides tools for making more complex web applications. \r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var server = vertx.createHttpServer();\r\n    \r\n    var Router = require(\"vertx-apex-js/router\");\r\n    var router = Router.router(vertx);\r\n    \r\n    router.route(\"/rest/v1/todo\").handler(function(routingContext) {\r\n      var response = routingContext.response();\r\n      response.putHeader(\"Content-Type\", \"text/html\");\r\n      response.end(\"<html><body><h1>Hello Vert.x!!!</h1></body></html>\");\r\n    });\r\n \r\n    server.requestHandler(router.accept).listen(9080);\r\n\r\nThe Router allows us to specify the exact request path which our handler will be called for. You can specify multiple handlers for a single path and call routingContext.next() in order to have the “next” handler also write to the output stream.\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var server = vertx.createHttpServer();\r\n    \r\n    var Router = require(\"vertx-apex-js/router\");\r\n    var router = Router.router(vertx);\r\n    \r\n    // Register a handler for requests to \"/rest/v1/todo\" and set the response to be \"chunked\" so we can \r\n    // append to the output\r\n    router.route(\"/rest/v1/todo\").handler(function(routingContext) {\r\n      var response = routingContext.response();\r\n      response.putHeader(\"Content-Type\", \"text/html\");\r\n      response.setChunked(true);\r\n      response.write(\"<html><body><h1>Hello Vert.x!!!</h1></body></html>\");\r\n      \r\n      // Tell Vert.x that 100ms after this content is sent that we want any other handlers registered to handle this\r\n      // path to be applied.\r\n      routingContext.vertx().setTimer(100, function(tld) {\r\n        routingContext.next();\r\n      });\r\n    });\r\n    \r\n    // This handler ALSO affects requests to \"/rest/v1/todo\" and it's output will come AFTER the first handler because\r\n    // of the timer in the first handler causing a delay.\r\n    router.route(\"/rest/v1/todo\").handler(function(routingContext) {\r\n      var response = routingContext.response();\r\n      response.setChunked(true);\r\n      response.write(\"<!-- Comment at the end -->\");\r\n      response.end();\r\n    });\r\n    \r\n    // router.accept is the \"handler\" for the requestHandler.\r\n    server.requestHandler(router.accept).listen(9080);\r\n\r\nBut static URLs SUCK, so let's make it more useful!\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var server = vertx.createHttpServer();\r\n    \r\n    var Router = require(\"vertx-apex-js/router\");\r\n    var router = Router.router(vertx);\r\n    \r\n    router.route(\"/rest/v1/todo/:id\").handler(function(routingContext) {\r\n      var response = routingContext.response();\r\n      response.putHeader(\"Content-Type\", \"text/html\");\r\n      response.setChunked(true);\r\n      response.write(\"<html><body><h1>Hello Vert.x!!! - \"+routingContext.request().getParam(\"id\")+\"</h1></body></html>\");\r\n      routingContext.vertx().setTimer(100, function(tld) {\r\n        routingContext.next();\r\n      });\r\n    });\r\n    \r\n    router.route(\"/rest/v1/todo/:id\").handler(function(routingContext) {\r\n      var response = routingContext.response();\r\n      response.setChunked(true);\r\n      response.write(\"<!-- Comment at the end -->\");\r\n      response.end();\r\n    });\r\n    \r\n    server.requestHandler(router.accept).listen(9080);\r\n\r\nThis is demonstrating how to insert path parameters into the router so that it is easy to use URL based params..\r\n\r\nBut for ReST APIs, we will want to break out the different HTTP methods:\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var server = vertx.createHttpServer();\r\n    \r\n    var Router = require(\"vertx-apex-js/router\");\r\n    var router = Router.router(vertx);\r\n    \r\n    router.get(\"/rest/v1/todo\").handler(function(routingContext) {\r\n      var response = routingContext.response();\r\n      response.putHeader(\"Content-Type\", \"text/html\");\r\n      response.setChunked(true);\r\n      response.end(\"<html><body><h1>Hello Vert.x!!!</h1></body></html>\");\r\n    });\r\n    \r\n    router.post(\"/rest/v1/todo\").handler(function(routingContext) {\r\n      var response = routingContext.response();\r\n      response.setStatusCode(202).setStatusMessage(\"ACCEPTED\").putHeader(\"Content-Type\", \"text/plain\").end(\"SUCCESS\");\r\n    });\r\n    \r\n    server.requestHandler(router.accept).listen(9080);\r\n\r\nSo that get's you through the basics of HTTP related stuff in Vert.x… Now, let's write a real application. A webchat which makes use of Vert.x's ability to bridge the event bus over WebSockets to the browser! Oh, and for giggles, we'll make it distrubuted so that different parts run on different hosts in an HA configuration!\r\n\r\nSo, create a new project from the archetype we used in the beginning:\r\n\r\n    mvn archetype:generate -DarchetypeGroupId=com.zanclus.codepalousa -DarchetypeArtifactId=vertx-js-archetype -DarchetypeVersion=3.0.0.6\r\n\r\nLet's start with the main verticle… For automatic redeployment purposes, this verticle will do nothing but load our other verticles.\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var verticleId = vertx.deployVerticle(\"com/codepalousa/vertx/webserver.js\");\r\n    var verticleId = vertx.deployVerticle(\"com/codepalousa/vertx/chat.js\");\r\n\r\nBecause of how the automatic redeloyment works, the main verticle cannot be reloaded, but every other verticle can be.\r\n\r\nNext, we create our webserver.js verticle:\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var Router = require(\"vertx-apex-js/router\");\r\n    var SockJSHandler = require(\"vertx-apex-js/sock_js_handler\");\r\n    var StaticHandler = require(\"vertx-apex-js/static_handler\");\r\n    \r\n    // Create an instance of an Apex Router\r\n    var router = Router.router(vertx);\r\n\r\n    // Allow events for the designated addresses in/out of the event bus bridge\r\n    // ONLY addresses listed here are allowed to traverse the Event Bus to/from the browser\r\n    var opts = {\r\n      \"inboundPermitteds\" : [\r\n        {\r\n          \"address\" : \"chat.to.server\"\r\n        }\r\n      ],\r\n      \"outboundPermitteds\" : [\r\n        {\r\n          \"address\" : \"chat.to.client\"\r\n        }\r\n      ]\r\n    };\r\n\r\n    // Create the event bus bridge and add it to the router.\r\n    // This uses web sockets to \"bridge\" the event bus to the browser\r\n    var ebHandler = SockJSHandler.create(vertx).bridge(opts);\r\n    router.route(\"/eventbus/*\").handler(ebHandler.handle);\r\n\r\n    // Create a router endpoint for the static content.\r\n    router.route().handler(StaticHandler.create().handle);\r\n\r\n    var server = vertx.createHttpServer().requestHandler(router.accept).listen(9080);\r\n\r\n    console.log(\"Web server verticle deployed.\");\r\n\r\nWe'll use several Vert.x extensions here. Apex, auth-service, and core. \r\n\r\nVert.x has a component called the SockJSHandler which allows you to connect from a Vert.x event bus implementation in the browser to the event bus on the server/cluster. This means that you can send event bus messages to/from the browser and have a completely reactive application. No need for server polling, no need for rest requests, just events!\r\n\r\nWe'll need to create a place to store our static HTML/CSS/JavaScript content for the web application. The StaticHandler which is built-in to Vert.x defaults to a directory in the working directory called “webroot”. For our maven project, the working directory is <project dir>/src/main/resources/\r\n\r\nIn that directory, we need to create an index.html page which will have our UI and we will also need to copy in the *vertxbus.js* library for the browser.\r\n\r\nThe *vertxbus.js* file can be found in the Vert.x distribution archive we downloaded earlier *<root>/client/vertxbus-<version>.js*\r\n\r\n    <html>\r\n    <head>\r\n      <title>Distributed Chat Service</title>\r\n      <meta charset=\"UTF-8\">\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n      <script src=\"https://code.jquery.com/jquery-1.11.2.min.js\"></script>\r\n      <script src=\"//cdn.jsdelivr.net/sockjs/0.3.4/sockjs.min.js\"></script>\r\n      <script src=\"vertxbus.js\"></script>\r\n      <script src=\"app.js\"></script>\r\n      <link href=\"styles.css\" type=\"text/css\" rel=\"stylesheet\"/>\r\n    </head>\r\n    <body>\r\n    Name: <input id=\"name\" type=\"text\" size=\"40\">\r\n    <div id=\"chat\" class=\"inset\"></div>\r\n    <input id=\"input\" type=\"text\" onkeydown=\"keyUpEvent(event)\" class=\"inset\" disabled>\r\n    </body>\r\n    </html>\r\n\r\nThe *styles.css* file is shown below. It is NOT pretty, but it should work for demonstration purposes.\r\n\r\n    .inset {\r\n      box-shadow: inset 0 0 4px #000000;\r\n      -moz-box-shadow: inset 0 0 4px #000000;\r\n      -webkit-box-shadow: inset 0 0 4px #000000;\r\n      border-width: 4px;\r\n      width: 99%;\r\n      padding: 5px;\r\n    }\r\n    input.inset {\r\n      width: 100%;\r\n    }\r\n    div.inset {\r\n      height: 90%;\r\n      overflow: auto;\r\n    }\r\n    div.timestamp {\r\n      width: 250px;\r\n      float: left;\r\n    }\r\n    div.content {\r\n      overflow: hidden;\r\n      width: auto;\r\n      border-left: 2px solid darkgreen;\r\n      padding-left: 3px;\r\n    }\r\n    div.entry {\r\n      border-bottom: 1px solid #cccccc;\r\n    }\r\n\r\nOK, we'll come back to the web content in a bit..\r\n\r\nNext, we need a *chat.js* verticle to handle event bus messages from the client.\r\n\r\n    /* global vertx */\r\n    /* global console */\r\n    var eb = vertx.eventBus();\r\n\r\n    // Receive message from the browser and then broadcast that message back out to all connected clients.\r\n    eb.consumer(\"client.to.server\").handler(function(message) {\r\n      console.log(\"Message from client: \"+message.body().content);\r\n      var reply = message.body();\r\n      var msgTime = new Date();\r\n      reply[\"timestamp\"] = msgTime.toLocaleDateString()+' '+msgTime.toLocaleTimeString();\r\n\r\n      eb.publish(\"server.to.client\", reply);\r\n    });\r\n\r\n    console.log(\"Chat verticle deployed.\");\r\n\r\nNext, let's add the event bus code to the *app.js* file which will be loaded into the HTML page.\r\n\r\n    // Define *eb* (Event Bus) and *backoff* as globals\r\n    var eb = {};\r\n    var backoff = 0;\r\n    \r\n    // This function will initialize the event bus and set up all of our event handlers.\r\n    function initEventBus() {\r\n      console.log(\"Attempting to connect to the eventbus.\");\r\n\r\n      // Create an instance of the Vert.x event bus. The path should match the path defined in the router\r\n      // inside of *webserver.js* (minus the trailing asterisk).\r\n      eb = new vertx.EventBus(\"/eventbus/\");\r\n\r\n      // Once the event bus connection is established, enable the form input field and register a listener for server\r\n      // messages.\r\n      eb.onopen = function () {\r\n        console.log(\"Eventbus connected.\");\r\n        \r\n        // Reset the *backoff* to 0\r\n        backoff = 0;\r\n        \r\n        // OK, event bus connected. Allow the user to type stuff into the input field.\r\n        $('#input').prop('disabled', false);\r\n\r\n        // Register listener for events coming from the server with new messages for the client.\r\n        eb.registerHandler(\"server.to.client\", function (msg) {\r\n          console.log(\"Message from server: \"+msg);\r\n          var entry = '<div class=\"entry\"><div class=\"timestamp\">'+\r\n                      msg.timestamp+': '+msg.user+'</div><div class=\"content\">'+\r\n                      msg.content+'</div></div>\\n';\r\n          $('#chat').append(entry);\r\n          $('#chat').attr({ scrollTop: $(\"#chat\").attr(\"scrollHeight\") });\r\n        });\r\n      };\r\n\r\n      // When the event bus connection closes, attempt to reconnect. If reconnect fails multiple times the reconnection\r\n      // attempts get slower until it tries every 10 seconds. Also, disables the input form element to prevent typing.\r\n      eb.onclose = function() {\r\n        console.log(\"Eventbus connection lost.\");\r\n        $('#input').prop('disabled', true);\r\n        if (backoff<10000) {\r\n          backoff += 1000;\r\n        }\r\n\r\n        // Tell the browser to reconnect the eventbus in 'backoff' milliseconds.\r\n        window.setTimeout(function() {\r\n          initEventBus();\r\n        }, backoff);\r\n      };\r\n    }\r\n\r\n    // Initialize the event bus and event handlers.\r\n    initEventBus();\r\n\r\n    // Watch the input field for the 'ENTER' key and send messages when 'ENTER' is pressed.\r\n    function keyUpEvent(event) {\r\n      if (event.keyCode == 13 || event.which == 13) {\r\n        var message = $('#input').val();\r\n        if (message.length > 0) {\r\n          var msg = {\"content\": message, \"user\": $('#name').val()};\r\n          console.log(msg);\r\n          eb.send(\"client.to.server\", msg);\r\n          $('#input').val(\"\");\r\n        }\r\n      }\r\n    }\r\n\r\nIn this JavaScript snippet, we are doing a few things:\r\n\r\n1. We create a function to instantiate the event bus\r\n2. Once the event bus connects, we register a consumer for the address which will receive messages from the server.\r\n3. We create a function which will send a message to the server when the <CR> key is pressed.\r\n4. We register a callback for if the event bus disconnects we will try to reconnect.\r\n\r\nWhenever handling a message coming from the event bus, remember that you MUST call the “body()” method to actually get \r\nthe message content. I used jQuery in this example, but there is an \r\n[AngularJS library](https://github.com/knalli/angular-vertxbus) for interfacing with Vert.x as well… The up side of the \r\nAngular library is that it supports automatic reconnection of the event bus bridge in case your service restarts or \r\nthere is a connectivity issue.\r\n\r\nThat's it! You now have a chat application in Vert.x! The hardest code was on the client side for handling \r\nreconnections. You could launch this application from Maven using the command:\r\n\r\n    mvn exec:java\r\n\r\nYou could also package the application and run it as a standalone application:\r\n\r\n    mvn clean compile package\r\n    java -jar target/codepalousa-vertx-chat-example-1.0-SNAPSHOT-fat.jar\r\n\r\nThe packaged JAR file should run anywhere you have Java 8 installed. If you need clustering, you just need to add the \r\ncluster flag. In some situations, you will have to customize the cluster.xml configuration to force clustering to choose\r\nthe appropriate network interface to do cluster communications on.\r\n\r\n    java -jar target/codepalousa-vertx-chat-example-1.0-SNAPSHOT-fat.jar -cluster\r\n\r\nQuestions? Suggestions? Complaints? Improvements? Let me know!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}